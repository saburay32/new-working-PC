'''
    Пятнашки (на поле произвольного размера)
    Пример таких "пятнашек" размера 4х6 из советского прошлого:

    Не сложно догадаться, что тот же принцип определения чётности перестановки лежит в основе определения возможности "выиграть", находясь в любой стартовой позиции "пятнашек" на произвольном поле размера NхM, где N и M не меньше 2.
    Реализуйте алгоритм, который:

    принимает на вход 2 числа, разделённых пробелом (n m)
    принимает на вход n строк с числами, разделёнными пробелом (в n-1 строке будет m чисел, а в последней строке будет m-1 число)
    Считая, что числа записаны "змейкой" (аналогично задаче 3.2), определить может ли данная игровая ситуация быть приведена к "выигрышной". Для этого определяем чётность перестановки "эталонной" позиции и сравниваем с чётностью перестановки текущей позиции.
    Если чётности равны, вывести "Бинго!"
    Если чётности отличаются, вывести "Не повезло..."

    Примечание.

    Эталонная комбинация для поля NxM содержит N*M-1N∗M−1 чисел по порядку от 11 до N*M-1N∗M−1 (т.к. последняя ячейка остаётся пустой).
    
    При этом

    первые n-1 строк содержат по m чисел
    последняя строка содержит m-1 число
    Подумайте как можно записать ряд чисел в i-й строке.
'''

n, m = map(int, input().split())
ans = []
z = 1
for i in range(n):
    q = [int(y) for y in range(i * m + 1, m * (i + 1) + 1)]
    ans += (q[::z])
    z *= -1
ans = ans[:int(n * m) - 1]

ins = []
for i in range(n):
    q = [int(i) for i in input().split()]
    ins += q[:]


def ch(x):
    w = 1
    for i in x:
        for y in x[x.index(i):]:
            if i > y:
                w *= -1
    return w


if ch(ins) == ch(ans):
    print("Бинго!")
else:
    print("Не повезло...")